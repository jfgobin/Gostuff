/* ***********************************************
 * go package malwarelist
 *
 * gets a string defining the method (URL,FILE)
 * and a string defining the target:
 * if the method is URL, the target is the url
 * to download the list
 * if the method is FILE, the target is the file
 * from where to get the IPs.
 *
 * For both, a regular expression is used to
 * extract whatever looks like an IP address
 * and ignore the rest of the line.
 *
 * This returns a list of all (distinct)
 * IP addresses read.
 *
 * If the argument "debug" is set,
 * print additional information.
 *
 * Revisions
 * ---------
 *
 * 2014 05 24 - v1.0 - Jean Gobin
 *********************************************** */

package malwarelist

/* Imports */

import (
	"bufio"
	"fmt"
	"os"
	"regexp"
	"net/http"
)

/* Global variables */

var Version_major int = 1
var Version_minor int = 0

/* Functions */

func Getmalwarelist(method string, target string, debug bool) []string {
	var (
		iplist []string
	)
	switch method {
	case "URL":
		if debug {
			fmt.Printf("DEBUG: Getmalwarelist(): URL method selected, url is %s\n", target)
		}
		iplist = Getlistfromurl(target, debug)
	case "FILE":
		if debug {
			fmt.Printf("DEBUG: Getmalwarelist(): FILE method selected, file is %s\n", target)
		}
		iplist = Getlistfromfile(target, debug)
	default:
		fmt.Printf("WARNING: Unimplemented method (%s)!\n",method)
		return nil
	}
	if len(iplist) == 0 {
		return nil
	}
	return iplist
}

/* Gets a line and returns the (potential) IP or "" */
func GetIPaddress(line string) string {
	re := regexp.MustCompile("^([0-9]+[.]){3}[0-9]+")
	matched := re.FindString(line)
	return string(matched)
}

/* Get the list from a file */
func Getlistfromfile(filename string, debug bool) []string {
	var (
		ips                 []string
	)
	f, err := os.Open(filename)
	if err != nil {
		if debug {
			fmt.Printf("DEBUG: Getlistfromfile(): Error while trying to open %s (%s)\n", filename, err)
		}
		return make([]string, 0)
	}
	ips = make([]string, 0)
	r := bufio.NewReader(f)
	ips=Readentries(r,debug)
	f.Close()
	if debug {
		fmt.Println("DEBUG: Getlistfromfile(): returning ", ips)
	}
	return ips
}

/* Connects to a URL and gets the list of IPs */
func Getlistfromurl(url string, debug bool) []string {
	var (
		ips []string
	)
	resp,err := http.Get(url)
	if err != nil {
		if debug {
			fmt.Printf("DEBUG: Getlistfromurl(): error while trying to open %s (%s)\n",url,err)
		}
		return make([]string,0)
	}
	ips=Readentries(bufio.NewReader(resp.Body),debug)
	return ips
}

/* Takes a bufio.Reader and returns an array of strings containing the IPs */
func Readentries(r *bufio.Reader,debug bool) []string {
	var (
		line, newip         string
		ips                 []string
		isPrefix, isPresent bool
		errread             error
		lineread, linebyte  []byte
	)
	errread = nil
	for errread == nil {
		isPrefix = true
		for errread == nil && isPrefix {
			lineread, isPrefix, errread = r.ReadLine()
			linebyte = append(linebyte, lineread...)
		}
		line = string(linebyte)
		if debug {
			fmt.Printf("DEBUG: Readentries(): read %s\n", line)
		}
		newip = GetIPaddress(line)
		if newip != "" {
			isPresent = false
			for k := 0; k < len(ips); k++ {
				if newip == ips[k] {
					isPresent = true
					break
				}
			}
			if isPresent == true {
				if debug {
					fmt.Printf("DEBUG: Getlistfromfile(): %s already present in list. Not appending.\n", newip)
				}
			} else {
				ips = append(ips, newip)
				if debug {
					fmt.Printf("DEBUG: Getlistfromfile(): len(ips)=%d\n", len(ips))
				}
			}
		}
		linebyte = nil
	}
	return ips
}
